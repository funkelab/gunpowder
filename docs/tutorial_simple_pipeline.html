

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial: A Simple Pipeline &mdash; gunpowder 1.2.2 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/jupyter-sphinx.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial: Writing Your Own Node" href="tutorial_batch_provider.html" />
    <link rel="prev" title="Installation" href="install.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html">
          

          
            
            <img src="_static/gunpowder.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: A Simple Pipeline</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#a-minimal-pipeline">A minimal pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#random-samples">Random samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometric-augmentation">Geometric augmentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intensity-augmentation">Intensity augmentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-batches-with-multiple-samples">Creating batches with multiple samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requesting-multiple-arrays">Requesting multiple arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="#training-a-network">Training a network</a></li>
<li class="toctree-l2"><a class="reference internal" href="#predicting-on-a-whole-image">Predicting on a whole image</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-next">What next?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_batch_provider.html">Tutorial: Writing Your Own Node</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial_batch_provider.html#the-basics-prepare-and-process">The basics: <code class="docutils literal notranslate"><span class="pre">prepare</span></code> and <code class="docutils literal notranslate"><span class="pre">process</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_batch_provider.html#changing-an-array-in-place">Changing an array in-place</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_batch_provider.html#requesting-additional-data">Requesting additional data</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial_batch_provider.html#creating-new-arrays">Creating new arrays</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html#data-containers">Data Containers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#batch">Batch</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#array">Array</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#graph">Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#node">Node</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#edge">Edge</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#arraykey">ArrayKey</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#graphkey">GraphKey</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#requests-and-specifications">Requests and Specifications</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#providerspec">ProviderSpec</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#batchrequest">BatchRequest</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#arrayspec">ArraySpec</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#graphspec">GraphSpec</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#geometry">Geometry</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#coordinate">Coordinate</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#roi">Roi</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#node-base-classes">Node Base Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#batchprovider">BatchProvider</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#batchfilter">BatchFilter</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#source-nodes">Source Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#zarrsource">ZarrSource</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#hdf5source">Hdf5Source</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#klbsource">KlbSource</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#dvidsource">DvidSource</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#csvpointssource">CsvPointsSource</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#augmentation-nodes">Augmentation Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#defectaugment">DefectAugment</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#elasticaugment">ElasticAugment</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#intensityaugment">IntensityAugment</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#noiseaugment">NoiseAugment</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#simpleaugment">SimpleAugment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#location-manipulation-nodes">Location Manipulation Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#crop">Crop</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#pad">Pad</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#randomlocation">RandomLocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#reject">Reject</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#specifiedlocation">SpecifiedLocation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#array-manipulation-nodes">Array Manipulation Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#squeeze">Squeeze</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#unsqueeze">Unsqueeze</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#image-processing-nodes">Image Processing Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#downsample">DownSample</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#upsample">UpSample</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#intensityscaleshift">IntensityScaleShift</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#normalize">Normalize</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#label-manipulation-nodes">Label Manipulation Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#addaffinities">AddAffinities</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#balancelabels">BalanceLabels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#excludelabels">ExcludeLabels</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#growboundary">GrowBoundary</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#renumberconnectedcomponents">RenumberConnectedComponents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#point-processing-nodes">Point Processing Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#rasterizegraph">RasterizeGraph</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#provider-combination-nodes">Provider Combination Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#mergeprovider">MergeProvider</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#randomprovider">RandomProvider</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#training-and-prediction-nodes">Training and Prediction Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#stack">Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#torch-train">torch.Train</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#torch-predict">torch.Predict</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#tensorflow-train">tensorflow.Train</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#tensorflow-predict">tensorflow.Predict</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#module-gunpowder">Output Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#hdf5write">Hdf5Write</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#zarrwrite">ZarrWrite</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#snapshot">Snapshot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#performance-nodes">Performance Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#precache">PreCache</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#printprofilingstats">PrintProfilingStats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api.html#iterative-processing-nodes">Iterative Processing Nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="api.html#scan">Scan</a></li>
<li class="toctree-l3"><a class="reference internal" href="api.html#daisyrequestblocks">DaisyRequestBlocks</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="example_boundaries.html">Example: Boundary Prediction for Instance Segmentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="example_boundaries.html#create-a-network-to-train-with">Create a network to train with</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_boundaries.html#assemble-the-training-pipeline">Assemble the training pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_boundaries.html#assemble-the-testing-pipeline">Assemble the testing pipeline</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">gunpowder</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Tutorial: A Simple Pipeline</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tutorial_simple_pipeline.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="module-gunpowder"><span id="sec-tutorial-simple-pipeline"></span></span><div class="section" id="tutorial-a-simple-pipeline">
<h1>Tutorial: A Simple Pipeline<a class="headerlink" href="#tutorial-a-simple-pipeline" title="Permalink to this headline">¶</a></h1>
<p>The following illustrates how a pipeline like the one above is built using
<code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>. We will build the pipeline incrementally and see what effect
each change has. Therefore, this tutorial is best read in that order.
Nevertheless, feel free to jump ahead to any of the following topics we are
covering here:</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#a-minimal-pipeline" id="id1">A minimal pipeline</a></p></li>
<li><p><a class="reference internal" href="#random-samples" id="id2">Random samples</a></p></li>
<li><p><a class="reference internal" href="#geometric-augmentation" id="id3">Geometric augmentation</a></p></li>
<li><p><a class="reference internal" href="#intensity-augmentation" id="id4">Intensity augmentation</a></p></li>
<li><p><a class="reference internal" href="#creating-batches-with-multiple-samples" id="id5">Creating batches with multiple samples</a></p></li>
<li><p><a class="reference internal" href="#requesting-multiple-arrays" id="id6">Requesting multiple arrays</a></p></li>
<li><p><a class="reference internal" href="#training-a-network" id="id7">Training a network</a></p></li>
<li><p><a class="reference internal" href="#predicting-on-a-whole-image" id="id8">Predicting on a whole image</a></p></li>
<li><p><a class="reference internal" href="#what-next" id="id9">What next?</a></p></li>
</ul>
</div>
<p>To rerun the example given here yourself, have a look at the
following preliminaries (or simply head over to this tutorial’s
<a class="reference external" href="https://colab.research.google.com/drive/1gyks3PYsD4xUZkwVzuXGPIYdr59fEYNa#scrollTo=-m4wLcJNIv6A">Colab notebook</a>):</p>
<div class="toggle admonition">
<p class="admonition-title">Tutorial Preliminaries: Data Preparation and Helpers</p>
<p>To follow the example here, install those packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">gunpowder</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">zarr</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">matplotlib</span>
</pre></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">zarr</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">filters</span>

<span class="c1"># make sure we all see the same</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19623</span><span class="p">)</span>
<span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">19623</span><span class="p">)</span>

<span class="c1"># open a sample image (channels first)</span>
<span class="n">raw_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># create some dummy &quot;ground-truth&quot; to train on</span>
<span class="n">gt_data</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.75</span>
<span class="n">gt_data</span> <span class="o">=</span> <span class="n">gt_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># store image in zarr container</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_data</span>
<span class="n">f</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="s1">&#39;ground_truth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gt_data</span>
<span class="n">f</span><span class="p">[</span><span class="s1">&#39;ground_truth&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># helper function to show image(s), channels first</span>
<span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">ground_truth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prediction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="n">rows</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">ground_truth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">rows</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">prediction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">rows</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">cols</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="mi">1</span>
  <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
      <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
  <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">ground_truth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ground_truth</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ground_truth</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ground_truth</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">prediction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prediction</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
</div>
<p>The data we are working with is shown below. It is stored in a <code class="docutils literal notranslate"><span class="pre">zarr</span></code>
container <code class="docutils literal notranslate"><span class="pre">sample_data.zarr</span></code> in dataset called <code class="docutils literal notranslate"><span class="pre">raw</span></code>, which has one
attribute <code class="docutils literal notranslate"><span class="pre">resolution</span> <span class="pre">=</span> <span class="pre">(1,</span> <span class="pre">1)</span></code>:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imshow</span><span class="p">(</span><span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)[</span><span class="s1">&#39;raw&#39;</span><span class="p">][:])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_1_0.png" src="_images/tutorial_simple_pipeline_1_0.png" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">resolution</span></code> attribute in the zarr dataset will be read by
<code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>. <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> supports anisotropic resultions and even
datasets with different resolutions in the same pipeline. Here, it tells
<code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> that this is a 2D dataset, with the remaining dimension to be
interpreted as channels. More on this later.</p>
</div>
<div class="section" id="a-minimal-pipeline">
<span id="sub-minimal-pipeline"></span><h2><a class="toc-backref" href="#id1">A minimal pipeline</a><a class="headerlink" href="#a-minimal-pipeline" title="Permalink to this headline">¶</a></h2>
<p>The first step for every pipeline is to declare the <strong>arrays</strong> that will be
used. For now, we will need only one array which we call <code class="docutils literal notranslate"><span class="pre">raw</span></code>:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gunpowder</span> <span class="k">as</span> <span class="nn">gp</span>

<span class="c1"># declare arrays to use in the pipeline</span>
<span class="n">raw</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArrayKey</span><span class="p">(</span><span class="s1">&#39;RAW&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Next we assemble the pipeline itself. To illustrate how <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> works, we
will do this step by step and look at the changes each step introduces. We
start with a “pipeline” consisting only of a data source.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># create &quot;pipeline&quot; consisting only of a data source</span>
<span class="n">source</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ZarrSource</span><span class="p">(</span>
    <span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span>  <span class="c1"># the zarr container</span>
    <span class="p">{</span><span class="n">raw</span><span class="p">:</span> <span class="s1">&#39;raw&#39;</span><span class="p">},</span>  <span class="c1"># which dataset to associate to the array key</span>
    <span class="p">{</span><span class="n">raw</span><span class="p">:</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArraySpec</span><span class="p">(</span><span class="n">interpolatable</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>  <span class="c1"># meta-information</span>
<span class="p">)</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">source</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>The pipeline by itself does nothing until we request data from it. What exactly
is requested is specified by a <a class="reference internal" href="api.html#gunpowder.BatchRequest" title="gunpowder.BatchRequest"><code class="xref py py-class docutils literal notranslate"><span class="pre">BatchRequest</span></code></a>. The following shows how
to create a request for “raw” data, starting at <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> with a size of
<code class="docutils literal notranslate"><span class="pre">(64,</span> <span class="pre">64)</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># formulate a request for &quot;raw&quot;</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">BatchRequest</span><span class="p">()</span>
<span class="n">request</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>The request behaves like a dictionary, mapping each array key to a region of
interest (ROI), i.e., an offset and a size.</p>
<p>It remains to <strong>build</strong> the pipeline and request a <a class="reference internal" href="api.html#gunpowder.Batch" title="gunpowder.Batch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Batch</span></code></a>:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># build the pipeline...</span>
<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>

  <span class="c1"># ...and request a batch</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="c1"># show the content of the batch</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;batch returned: </span><span class="si">{</span><span class="n">batch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>batch returned: 
	RAW: ROI: [0:64, 0:64] (64, 64), voxel size: (1, 1), interpolatable: True, non-spatial: False, dtype: uint8, placeholder: False

</pre></div>
</div>
<img alt="_images/tutorial_simple_pipeline_5_1.png" src="_images/tutorial_simple_pipeline_5_1.png" />
</div>
</div>
<p>The returned batch contains a crop of the source image, located in the top left
corner. This is indeed exactly what we requested, as an inspection of our
request reveals:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>
	RAW: ROI: [0:64, 0:64] (64, 64), voxel size: None, interpolatable: None, non-spatial: False, dtype: None, placeholder: False

</pre></div>
</div>
</div>
</div>
<p>As we can see, the request for <code class="docutils literal notranslate"><span class="pre">RAW</span></code> (the name we gave to our array key) is
for a ROI that begins at 0 and ends at 64 for each dimension, giving it a shape
of <code class="docutils literal notranslate"><span class="pre">(64,</span> <span class="pre">64)</span></code>. The <a class="reference internal" href="api.html#gunpowder.ZarrSource" title="gunpowder.ZarrSource"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZarrSource</span></code></a> simply delivered on exactly this
request.</p>
<div class="toggle admonition">
<p class="admonition-title">Further Example: Change Request Offset</p>
<p>To create a request for data in a specific area of the source, we simply
change the offset in the request <a class="reference internal" href="api.html#gunpowder.Roi" title="gunpowder.Roi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Roi</span></code></a>:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">request</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
<span class="c1">#                     ^^^^^^^^^</span>
<span class="c1">#                     changed offset</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;batch returned: </span><span class="si">{</span><span class="n">batch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>batch returned: 
	RAW: ROI: [50:114, 150:214] (64, 64), voxel size: (1, 1), interpolatable: True, non-spatial: False, dtype: uint8, placeholder: False

</pre></div>
</div>
<img alt="_images/tutorial_simple_pipeline_7_1.png" src="_images/tutorial_simple_pipeline_7_1.png" />
</div>
</div>
</div>
</div>
<div class="section" id="random-samples">
<h2><a class="toc-backref" href="#id2">Random samples</a><a class="headerlink" href="#random-samples" title="Permalink to this headline">¶</a></h2>
<p>In training pipelines, however, it might be useful to randomly select a
location to crop data from. Doing this manually by changing the offset of the
ROI in the request we send for every iteration would be cumbersome. It would
also require that we know the size of the data in the source.</p>
<p>Instead, <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> provides a node <a class="reference internal" href="api.html#gunpowder.RandomLocation" title="gunpowder.RandomLocation"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomLocation</span></code></a> that does that
for us, we simply have to add it to our pipeline:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># add a RandomLocation node to the pipeline to randomly select a sample</span>

<span class="n">random_location</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">RandomLocation</span><span class="p">()</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">source</span> <span class="o">+</span> <span class="n">random_location</span>

<span class="nb">print</span><span class="p">(</span><span class="n">pipeline</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>ZarrSource[sample_data.zarr] -&gt; RandomLocation
</pre></div>
</div>
</div>
</div>
<p>When we now issue the same request, it will first be shifted by
<code class="docutils literal notranslate"><span class="pre">random_location</span></code> to a random location <em>within</em> the provided data.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_9_0.png" src="_images/tutorial_simple_pipeline_9_0.png" />
</div>
</div>
<p>This example illustrates two important concepts in <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>:</p>
<ol class="arabic simple">
<li><p>Request can (and will be) changed as they are passed upstream through the
pipeline. In this example, <a class="reference internal" href="api.html#gunpowder.RandomLocation" title="gunpowder.RandomLocation"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomLocation</span></code></a> changes the offset of the
request for us, such that we get data from a random location.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> nodes know what kind of data is provided upstream, and what
its extents are. Here, <a class="reference internal" href="api.html#gunpowder.RandomLocation" title="gunpowder.RandomLocation"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomLocation</span></code></a> uses this information to find
out where it can safely shift the request to.</p></li>
</ol>
</div>
<div class="section" id="geometric-augmentation">
<h2><a class="toc-backref" href="#id3">Geometric augmentation</a><a class="headerlink" href="#geometric-augmentation" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> provides many more nodes to be added to a pipeline, most of them
tailored towards training pipelines. The following example shows how to add
simple random <em>mirror</em> and <em>transpose</em> augmentations:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simple_augment</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">SimpleAugment</span><span class="p">()</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">source</span> <span class="o">+</span> <span class="n">random_location</span> <span class="o">+</span> <span class="n">simple_augment</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_10_0.png" src="_images/tutorial_simple_pipeline_10_0.png" />
</div>
</div>
<p>The <a class="reference internal" href="api.html#gunpowder.SimpleAugment" title="gunpowder.SimpleAugment"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleAugment</span></code></a> node will (by default) randomly mirror and/or
transpose batches passing through it. Notably, the transpose operation is
transparent, i.e., if we were to request data in a non-square ROI, we will
still get the size we asked for, transposed or not:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">request</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_11_0.png" src="_images/tutorial_simple_pipeline_11_0.png" />
</div>
</div>
<p>Simple augmentations like this are complemented by random rotations and elastic
deformations, which are provided by the <a class="reference internal" href="api.html#gunpowder.ElasticAugment" title="gunpowder.ElasticAugment"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElasticAugment</span></code></a> node:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="n">elastic_augment</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ElasticAugment</span><span class="p">(</span>
  <span class="n">control_point_spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
  <span class="n">jitter_sigma</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">),</span>
  <span class="n">rotation_interval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">source</span> <span class="o">+</span> <span class="n">random_location</span> <span class="o">+</span> <span class="n">simple_augment</span> <span class="o">+</span> <span class="n">elastic_augment</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_12_0.png" src="_images/tutorial_simple_pipeline_12_0.png" />
</div>
</div>
</div>
<div class="section" id="intensity-augmentation">
<h2><a class="toc-backref" href="#id4">Intensity augmentation</a><a class="headerlink" href="#intensity-augmentation" title="Permalink to this headline">¶</a></h2>
<p>Intensity values can be modified and random noise added in a similar fashion:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">normalize</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
<span class="n">intensity_augment</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">IntensityAugment</span><span class="p">(</span>
  <span class="n">raw</span><span class="p">,</span>
  <span class="n">scale_min</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
  <span class="n">scale_max</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span>
  <span class="n">shift_min</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span>
  <span class="n">shift_max</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">noise_augment</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">NoiseAugment</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">random_location</span> <span class="o">+</span>
  <span class="n">simple_augment</span> <span class="o">+</span>
  <span class="n">elastic_augment</span> <span class="o">+</span>
  <span class="n">intensity_augment</span> <span class="o">+</span>
  <span class="n">noise_augment</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_13_0.png" src="_images/tutorial_simple_pipeline_13_0.png" />
</div>
</div>
<p>We introduced two new concepts in this snippet:</p>
<p>First, we added a <a class="reference internal" href="api.html#gunpowder.Normalize" title="gunpowder.Normalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalize</span></code></a> node for <code class="docutils literal notranslate"><span class="pre">raw</span></code>. This node ensures that
the data type of the given array is <code class="docutils literal notranslate"><span class="pre">np.float64</span></code> from there on through the
pipeline. We have so far been agnostic about the exact datatype of <code class="docutils literal notranslate"><span class="pre">raw</span></code> (it
was <code class="docutils literal notranslate"><span class="pre">uint8</span></code>, by the way). However, in order to shift intensities and to add
random noise, it is helpful to ensure we are dealing with float values between
0 and 1. The normalization applied by <a class="reference internal" href="api.html#gunpowder.Normalize" title="gunpowder.Normalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalize</span></code></a> is data independent,
it is based on the data type of the source (or, optionally, on a user-specified
scaling factor).</p>
<p>Second, we introduced nodes that take array keys as arguments
(<a class="reference internal" href="api.html#gunpowder.Normalize" title="gunpowder.Normalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">Normalize</span></code></a>, <a class="reference internal" href="api.html#gunpowder.IntensityAugment" title="gunpowder.IntensityAugment"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntensityAugment</span></code></a>, and <a class="reference internal" href="api.html#gunpowder.NoiseAugment" title="gunpowder.NoiseAugment"><code class="xref py py-class docutils literal notranslate"><span class="pre">NoiseAugment</span></code></a>).
Those nodes limit their operation to the given keys, which is useful if our
batch also contains other arrays (like a ground-truth segmentation) that we do
not wish to modify.</p>
</div>
<div class="section" id="creating-batches-with-multiple-samples">
<h2><a class="toc-backref" href="#id5">Creating batches with multiple samples</a><a class="headerlink" href="#creating-batches-with-multiple-samples" title="Permalink to this headline">¶</a></h2>
<p>So far we have seen how to request a single sample in a “batch”. Normally,
however, batches consist of several samples drawn independently. This can be
done using the <a class="reference internal" href="api.html#gunpowder.Stack" title="gunpowder.Stack"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stack</span></code></a> node:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stack</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Stack</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">random_location</span> <span class="o">+</span>
  <span class="n">simple_augment</span> <span class="o">+</span>
  <span class="n">elastic_augment</span> <span class="o">+</span>
  <span class="n">intensity_augment</span> <span class="o">+</span>
  <span class="n">noise_augment</span> <span class="o">+</span>
  <span class="n">stack</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_14_0.png" src="_images/tutorial_simple_pipeline_14_0.png" />
</div>
</div>
</div>
<div class="section" id="requesting-multiple-arrays">
<h2><a class="toc-backref" href="#id6">Requesting multiple arrays</a><a class="headerlink" href="#requesting-multiple-arrays" title="Permalink to this headline">¶</a></h2>
<p>To train a model on data, we need a training signal as well. This signal can
come, for example, in the form of a binary segmentation stored alongside the
raw image data. For this tutorial, we will assume that such a binary
segmentation exists and is stored in the same <code class="docutils literal notranslate"><span class="pre">zarr</span></code> container in a dataset
called <code class="docutils literal notranslate"><span class="pre">ground_truth</span></code>. At the beginning of this tutorial, we created a dummy
segmentation to work with:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imshow</span><span class="p">(</span>
  <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)[</span><span class="s1">&#39;raw&#39;</span><span class="p">][:],</span>
  <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)[</span><span class="s1">&#39;ground_truth&#39;</span><span class="p">][:])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_15_0.png" src="_images/tutorial_simple_pipeline_15_0.png" />
</div>
</div>
<p>With a slight modification to the source node and our request, we can now
simultaneously request raw data and a segmentation:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gt</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArrayKey</span><span class="p">(</span><span class="s1">&#39;GROUND_TRUTH&#39;</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ZarrSource</span><span class="p">(</span>
    <span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="s1">&#39;raw&#39;</span><span class="p">,</span>
      <span class="n">gt</span><span class="p">:</span> <span class="s1">&#39;ground_truth&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="n">raw</span><span class="p">:</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArraySpec</span><span class="p">(</span><span class="n">interpolatable</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
      <span class="n">gt</span><span class="p">:</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArraySpec</span><span class="p">(</span><span class="n">interpolatable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="p">})</span>

<span class="n">request</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">random_location</span> <span class="o">+</span>
  <span class="n">simple_augment</span> <span class="o">+</span>
  <span class="n">elastic_augment</span> <span class="o">+</span>
  <span class="n">intensity_augment</span> <span class="o">+</span>
  <span class="n">noise_augment</span> <span class="o">+</span>
  <span class="n">stack</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_16_0.png" src="_images/tutorial_simple_pipeline_16_0.png" />
</div>
</div>
<p>As we can see, our batch does now contain aligned data for both <code class="docutils literal notranslate"><span class="pre">raw</span></code> and
<code class="docutils literal notranslate"><span class="pre">gt</span></code>. Notably, both arrays have been transformed in the same way as they were
passed through the pipeline, except for the intensity augmentation parts that
were exclusive to <code class="docutils literal notranslate"><span class="pre">raw</span></code>. This works even if the requested ROIs for <code class="docutils literal notranslate"><span class="pre">raw</span></code>
and <code class="docutils literal notranslate"><span class="pre">gt</span></code> are not identical. Here we see the effect of requesting a
ground-truth ROI that is offset relative to the raw ROI:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># request an offset ROI for ground-truth</span>
<span class="n">odd_request</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">odd_request</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">odd_request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_17_0.png" src="_images/tutorial_simple_pipeline_17_0.png" />
</div>
</div>
<p>This highlights another feature of <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>: Requests can contain ROIs
with different offsets and sizes. Internally, <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> will figure out
what areas in the source have to be read to satisfy those heterogeneous
requests, and will only read as much as needed to satisfy the request. This is
useful in many applications where ground-truth is not needed for the whole
input image (e.g., because of the use of valid convolutions in neural networks
and the correspondingly smaller network output).</p>
<div class="toggle admonition">
<p class="admonition-title">Further Example: Multiple Sources</p>
<p>For now we assumed that both arrays we are interested in (<code class="docutils literal notranslate"><span class="pre">raw</span></code> and <code class="docutils literal notranslate"><span class="pre">gt</span></code>)
are read from the same source, i.e., they are stored in the same <code class="docutils literal notranslate"><span class="pre">zarr</span></code>
container in this example. This might not always be the case. <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>
allows you to have multiple sources for different arrays and merge them
together into one. The following example shows this functionality:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">source_raw</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ZarrSource</span><span class="p">(</span>
    <span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span>
    <span class="p">{</span><span class="n">raw</span><span class="p">:</span> <span class="s1">&#39;raw&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">raw</span><span class="p">:</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArraySpec</span><span class="p">(</span><span class="n">interpolatable</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>
<span class="p">)</span>
<span class="n">source_gt</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ZarrSource</span><span class="p">(</span>
    <span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span>
    <span class="p">{</span><span class="n">gt</span><span class="p">:</span> <span class="s1">&#39;ground_truth&#39;</span><span class="p">},</span>
    <span class="p">{</span><span class="n">gt</span><span class="p">:</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArraySpec</span><span class="p">(</span><span class="n">interpolatable</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span>
<span class="p">)</span>
<span class="n">combined_source</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_raw</span><span class="p">,</span> <span class="n">source_gt</span><span class="p">)</span> <span class="o">+</span> <span class="n">gp</span><span class="o">.</span><span class="n">MergeProvider</span><span class="p">()</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">combined_source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">random_location</span> <span class="o">+</span>
  <span class="n">simple_augment</span> <span class="o">+</span>
  <span class="n">elastic_augment</span> <span class="o">+</span>
  <span class="n">intensity_augment</span> <span class="o">+</span>
  <span class="n">noise_augment</span> <span class="o">+</span>
  <span class="n">stack</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_18_0.png" src="_images/tutorial_simple_pipeline_18_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="training-a-network">
<h2><a class="toc-backref" href="#id7">Training a network</a><a class="headerlink" href="#training-a-network" title="Permalink to this headline">¶</a></h2>
<p>We have seen so far how <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> can be used to generate training batches.
In the following we will see how to train a neural network directly in this
pipeline. For the example, we will train a 2D U-Net (<code class="docutils literal notranslate"><span class="pre">model</span></code>) on the binary
ground-truth using a binary cross-entropy loss (<code class="docutils literal notranslate"><span class="pre">loss</span></code>). We will use <a class="reference external" href="https://pytorch.org/">PyTorch</a>, but the same can be done with a <a class="reference external" href="https://www.tensorflow.org/">TensorFlow</a> model as well.</p>
<div class="toggle admonition">
<p class="admonition-title">Training Preliminaries: Create Model, Loss, and Optimizer</p>
<p>We will use the U-Net implemention from <a class="reference external" href="https://github.com/funkelab/funlib.learn.torch">funlib.learn.torch</a>, but any PyTorch model can
be used. To follow the example, install those packages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">funkelab</span><span class="o">/</span><span class="n">funlib</span><span class="o">.</span><span class="n">learn</span><span class="o">.</span><span class="n">torch</span><span class="nd">@fe60a7d9a375d64208266f96a739ab01f62a0c78</span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">torch</span>
</pre></div>
</div>
<p>Here, we create a very simple 2D U-Net mapping from three channels (RGB of
the raw data) to one channel (the segmentation output). The U-Net has two
downsampling modules, downsampling isotropically with a factor of two. We use
‘same’ padding here, meaning that the output size of the U-Net will be the
same as the input size. The number of feature maps will be four in the
top-most level of the U-Net, and increase with a factor of two for each of
the two following levels. The output of the U-Net is further passed through a
sigmoid function to ensure values are between 0 and 1.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">funlib.learn.torch.models</span> <span class="kn">import</span> <span class="n">UNet</span><span class="p">,</span> <span class="n">ConvPass</span>

<span class="c1"># make sure we all see the same</span>
<span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>

<span class="n">unet</span> <span class="o">=</span> <span class="n">UNet</span><span class="p">(</span>
  <span class="n">in_channels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
  <span class="n">num_fmaps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
  <span class="n">fmap_inc_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">downsample_factors</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
  <span class="n">kernel_size_down</span><span class="o">=</span><span class="p">[[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
  <span class="n">kernel_size_up</span><span class="o">=</span><span class="p">[[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
  <span class="n">unet</span><span class="p">,</span>
  <span class="n">ConvPass</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">activation</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
  <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">())</span>

<span class="n">loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">BCELoss</span><span class="p">()</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
</div>
<p>Training itself is implemented in a <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> node, in this case
<a class="reference internal" href="api.html#gunpowder.torch.Train" title="gunpowder.torch.Train"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Train</span></code></a>. The main benefit of using this node in a
<code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> pipeline (compared to just taking the batches we requested so far
and feeding them manually to the model) is that the output of the network
itself can be mapped to a <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> array, and subsequently be used in the
pipeline. In the following, we will create a new array key <code class="docutils literal notranslate"><span class="pre">prediction</span></code> to do
exactly that:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># create new array key for the network output</span>
<span class="n">prediction</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ArrayKey</span><span class="p">(</span><span class="s1">&#39;PREDICTION&#39;</span><span class="p">)</span>

<span class="c1"># create a train node using our model, loss, and optimizer</span>
<span class="n">train</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Train</span><span class="p">(</span>
  <span class="n">model</span><span class="p">,</span>
  <span class="n">loss</span><span class="p">,</span>
  <span class="n">optimizer</span><span class="p">,</span>
  <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">raw</span>
  <span class="p">},</span>
  <span class="n">loss_inputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="n">prediction</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">gt</span>
  <span class="p">},</span>
  <span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="n">prediction</span>
  <span class="p">})</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">random_location</span> <span class="o">+</span>
  <span class="n">simple_augment</span> <span class="o">+</span>
  <span class="n">elastic_augment</span> <span class="o">+</span>
  <span class="n">intensity_augment</span> <span class="o">+</span>
  <span class="n">noise_augment</span> <span class="o">+</span>
  <span class="n">stack</span> <span class="o">+</span>
  <span class="n">train</span><span class="p">)</span>

<span class="c1"># add the prediction to the request</span>
<span class="n">request</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_20_0.png" src="_images/tutorial_simple_pipeline_20_0.png" />
</div>
</div>
<p>As we can see, our batch does now contain an array <code class="docutils literal notranslate"><span class="pre">prediction</span></code>, which is the
output of the <a class="reference internal" href="api.html#gunpowder.torch.Train" title="gunpowder.torch.Train"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Train</span></code></a> node. This illustrates another feature of
<code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>: Arrays can be generated by any node, this functionality is not
limited to source nodes (and in fact, source nodes are in no way special, they
are simply <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> nodes that do not require an input and provide an
array).</p>
<p>But the train node above did not just produce a prediction: Since we also told
it which loss and optimizer to use, and since we linked the output of our
network and the ground-truth to the loss via <code class="docutils literal notranslate"><span class="pre">loss_inputs</span></code>, the train node
did also perform a training iteration for us. This becomes more evident if we
keep training for a few iterations:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">gt</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_21_0.png" src="_images/tutorial_simple_pipeline_21_0.png" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The predictions are only included in the batch because we requested them here
to visualize them. To keep the example simple, we request the predictions in
every iteration. In a production setting, however, it is advisable to request
only what is needed for each iteration. This saves a potentially expensive
copy from GPU memory.</p>
</div>
</div>
<div class="section" id="predicting-on-a-whole-image">
<h2><a class="toc-backref" href="#id8">Predicting on a whole image</a><a class="headerlink" href="#predicting-on-a-whole-image" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> and its pipeline concept can not just be used for training, but
also to perform the final predictions once training is finished. The following
example shows how to assemble a pipeline to take the model we just trained and
apply it on the whole image. The main difficulty in doing that is that the
model was trained for a particular input size. Consequently, the whole image
will have to be chunked into pieces of the correct size, and the network has to
be applied to each chunk in a scanning fashion, creating predictions one chunk
at a time. Those chunks then have to be reassembled into a prediction for the
whole image. This whole procedure is orchestrated by another <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code>
node: <a class="reference internal" href="api.html#gunpowder.Scan" title="gunpowder.Scan"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scan</span></code></a>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># set model into evaluation mode</span>
<span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="n">predict</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">torch</span><span class="o">.</span><span class="n">Predict</span><span class="p">(</span>
  <span class="n">model</span><span class="p">,</span>
  <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">raw</span>
  <span class="p">},</span>
  <span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="n">prediction</span>
  <span class="p">})</span>

<span class="n">stack</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Stack</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># request matching the model input and output sizes</span>
<span class="n">scan_request</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">BatchRequest</span><span class="p">()</span>
<span class="n">scan_request</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
<span class="n">scan_request</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="n">scan</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Scan</span><span class="p">(</span><span class="n">scan_request</span><span class="p">)</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">stack</span> <span class="o">+</span>
  <span class="n">predict</span> <span class="o">+</span>
  <span class="n">scan</span><span class="p">)</span>

<span class="c1"># request for raw and prediction for the whole image</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">BatchRequest</span><span class="p">()</span>
<span class="n">request</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
<span class="n">request</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">Roi</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="n">imshow</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="n">raw</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch</span><span class="p">[</span><span class="n">prediction</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/tutorial_simple_pipeline_22_5.png" src="_images/tutorial_simple_pipeline_22_5.png" />
</div>
</div>
<p>The main difference to the training pipeline used earlier is that there is no
longer a need for data augmentation. We also replaced the <a class="reference internal" href="api.html#gunpowder.torch.Train" title="gunpowder.torch.Train"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Train</span></code></a>
node with its equivalent <a class="reference internal" href="api.html#gunpowder.torch.Predict" title="gunpowder.torch.Predict"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Predict</span></code></a>.</p>
<div class="toggle admonition">
<p class="admonition-title">Further Example: Prediction in Large nD Arrays</p>
<p>Here, we make a request to <a class="reference internal" href="api.html#gunpowder.Scan" title="gunpowder.Scan"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scan</span></code></a> for the whole image and the
prediction. This is fine as long as both arrays are small enough to fit into
memory. However, <code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> was designed to work with arbitrarily large
nD arrays. Therefore, <a class="reference internal" href="api.html#gunpowder.Scan" title="gunpowder.Scan"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scan</span></code></a> accepts empty requests as well, which
will still result in small <code class="docutils literal notranslate"><span class="pre">scan_request</span></code> s being performed in a scanning
fashion over the whole input range–the only difference is that <a class="reference internal" href="api.html#gunpowder.Scan" title="gunpowder.Scan"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scan</span></code></a>
does not keep the individual results and consequently that the batch returned
by <a class="reference internal" href="api.html#gunpowder.Scan" title="gunpowder.Scan"><code class="xref py py-class docutils literal notranslate"><span class="pre">Scan</span></code></a> will be empty.</p>
<p>So how do we get access to the prediction then to store it, for example, in a
<code class="docutils literal notranslate"><span class="pre">zarr</span></code> container? The answer is to add a node <strong>between</strong> predict and scan,
through which every batch will pass before it is being discarded. The
<a class="reference internal" href="api.html#gunpowder.ZarrWrite" title="gunpowder.ZarrWrite"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZarrWrite</span></code></a> node will, for instance, assemble a <code class="docutils literal notranslate"><span class="pre">zarr</span></code> container of
all the arrays passing through it.</p>
<p>The following example illustrates that:</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare the zarr dataset to write to</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;prediction&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
<span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># create a zarr write node to store the predictions</span>
<span class="n">zarr_write</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">ZarrWrite</span><span class="p">(</span>
  <span class="n">output_filename</span><span class="o">=</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">,</span>
  <span class="n">dataset_names</span><span class="o">=</span><span class="p">{</span>
    <span class="n">prediction</span><span class="p">:</span> <span class="s1">&#39;prediction&#39;</span>
  <span class="p">})</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="p">(</span>
  <span class="n">source</span> <span class="o">+</span>
  <span class="n">normalize</span> <span class="o">+</span>
  <span class="n">stack</span> <span class="o">+</span>
  <span class="n">predict</span> <span class="o">+</span>
  <span class="n">zarr_write</span> <span class="o">+</span>
  <span class="n">scan</span><span class="p">)</span>

<span class="c1"># request an empty batch from scan</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">BatchRequest</span><span class="p">()</span>

<span class="k">with</span> <span class="n">gp</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">request_batch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
<span class="n">imshow</span><span class="p">(</span>
  <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)[</span><span class="s1">&#39;raw&#39;</span><span class="p">][:],</span>
  <span class="kc">None</span><span class="p">,</span>
  <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;sample_data.zarr&#39;</span><span class="p">)[</span><span class="s1">&#39;prediction&#39;</span><span class="p">][:])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>

</pre></div>
</div>
<img alt="_images/tutorial_simple_pipeline_23_6.png" src="_images/tutorial_simple_pipeline_23_6.png" />
</div>
</div>
</div>
</div>
<div class="section" id="what-next">
<h2><a class="toc-backref" href="#id9">What next?</a><a class="headerlink" href="#what-next" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">gunpowder</span></code> provides much more nodes to chain together, including a
<a class="reference internal" href="api.html#sec-api-precache"><span class="std std-ref">pre-cache</span></a> node for easy parallel fetching of batches,
several <a class="reference internal" href="api.html#sec-api-augmentation-nodes"><span class="std std-ref">augmentation nodes</span></a>, and nodes for
<a class="reference internal" href="api.html#sec-api-profiling"><span class="std std-ref">profiling</span></a> and <a class="reference internal" href="api.html#sec-api-snapshot"><span class="std std-ref">inspection</span></a>.
For a complete list see the <a class="reference internal" href="api.html#sec-api"><span class="std std-ref">API reference</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tutorial_batch_provider.html" class="btn btn-neutral float-right" title="Tutorial: Writing Your Own Node" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Jan Funke, Will Patton, Renate Krause, Julia Buhmann, Rodrigo Ceballos Lentini, William Grisaitis, Chris Barnes, Caroline Malin-Mayor, Larissa Heinrich, Philipp Hanslovsky, Sherry Ding, Andrew Champion, Arlo Sheridan, Constantin Pape.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.2.2',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .admonition-title").show();
        $(".toggle .admonition-title").click(function() {
            $(this).parent().children().not(".admonition-title").toggle(400);
            $(this).parent().children(".admonition-title").toggleClass("open");
        })
    });
</script>


</body>
</html>